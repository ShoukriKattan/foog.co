var _ = require('underscore.js');
var utils = require("cloud/utils.js");
var moment = require('cloud/moment-timezone-with-data.js');

//TODO : What happens if coach changes day of week .. before a summary runs ...

var supportedTimezones=[
'Asia/Hebron',
'America/Toronto'
];

var weekday = new Array(7);
weekday[0] = "Sunday";
weekday[1] = "Monday";
weekday[2] = "Tuesday";
weekday[3] = "Wednesday";
weekday[4] = "Thursday";
weekday[5] = "Friday";
weekday[6] = "Saturday";

var daysToMillis = function(days) {

	return days * 24 * 60 * 60 * 1000;
};

var weekDayToString = function(weekDayInt) {
	return weekday[weekDayInt];
};

var initializeSummaryStructures = function(beginDate) {

	var dates = new Array();
	var groupedByDay = new Array();

	// take start date and add one day

	// fill the array by walking through the dates ...
	// dates array will also hold dates in that order
	// then setup what you need.
	//groupedByDay[day]={
	//dayOfWeek: day name (monday,tuesday,etc..) or day index.
	//meals: []  objects.
	//numberOfMeals : or we can do meals.length

	for (var daysToAdd = 0; daysToAdd < 7; daysToAdd++) {

		var theDate = new Date();
		theDate.setTime(beginDate.getTime() + daysToMillis(daysToAdd));

		var df = theDate.getDate() + "-" + (theDate.getMonth() + 1) + "-" + theDate.getFullYear();

		dates.push({
			label : df,
			day : theDate.getDay()
		});
		groupedByDay[df] = new Array();
	}

	return {
		dates : dates,
		groupedByDay : groupedByDay
	};

};

var groupMeals = function(mealsPerQueryWeek, beginDate) {

	var holdingDS = initializeSummaryStructures(beginDate);

	var dates = holdingDS.dates;
	var groupedByDay = holdingDS.groupedByDay;

	for (var i = 0; i < mealsPerQueryWeek.length; i++) {// All Query items ... which include multiple items per day

		var meal = mealsPerQueryWeek[i];

		console.log("Meal is " + JSON.stringify(meal));

		var createdAt = meal.get("appCreatedAt");

		var dateFormatted = createdAt.getDate() + "-" + (createdAt.getMonth() + 1) + "-" + createdAt.getFullYear();

		var dayOfWeek = createdAt.getDay();

		if (!groupedByDay[dateFormatted]) {
			//Should be ERROR HERE
			console.error("Group By Day Not Found " + dateFormatted);
		}

		var itemMarkers = meal.get("itemMarkers");

		console.log("Pushing meal " + dateFormatted + " meal created At : " + createdAt);

		groupedByDay[dateFormatted].push({
			createdAt : createdAt,
			itemMarkers : itemMarkers
		});

	}// end of loop on all items in the query mealsPerQueryWeek

	return {
		dates : dates,
		groupedByDay : groupedByDay
	};

};

var calculateAvgEfficiency = function(efficiencyDataWeekly) {

	var sumOf = 0;

	for (var j = 0; j < efficiencyDataWeekly.length; j++) {

		sumOf += efficiencyDataWeekly[j];

	}

	var avgEfficiency = sumOf / efficiencyDataWeekly.length;

	return avgEfficiency;

};

var calculateWeekSummary = function(mealsPerQueryWeek, beginDate) {

	var efficiencyDataWeekly = new Array();

	// These are total checks and crosses per fucking week...
	var noChecksPerWeek = 0;
	var noCrossesPerWeek = 0;
	var noMealsPerWeek = 0;

	var maximumMealsPerDay = 0;
	var maximumMealsPerDayIndex = 0;

	var holdingDS = groupMeals(mealsPerQueryWeek, beginDate);

	var dates = holdingDS.dates;
	var groupedByDay = holdingDS.groupedByDay;

	// For every day :
	for (var i = 0; i < dates.length; i++) {

		mealsPerDay = groupedByDay[dates[i].label];

		if (!mealsPerDay) {
			mealsPerDay = [];
		}

		console.log("Meals Per Day : " + JSON.stringify(mealsPerDay));

		var noMealsPerDay = mealsPerDay.length;

		noMealsPerWeek += noMealsPerDay;

		var checksPerDay = 0;
		var crossesPerDay = 0;
		var efficiencyPerDay = 0;

		if (noMealsPerDay > maximumMealsPerDay) {
			maximumMealsPerDay = noMealsPerDay;
			maximumMealsPerDayIndex = i;
		}

		// For every meal in that day ...
		for (var j = 0; j < mealsPerDay.length; j++) {

			// For every day , add all meals per day...
			var dayMeal = mealsPerDay[j];

			var itemMarkers = dayMeal.itemMarkers;

			if (!itemMarkers) {
				itemMarkers = [];
			}

			for (var markerIndex = 0; markerIndex < itemMarkers.length; markerIndex++) {

				var marker = itemMarkers[markerIndex];

				var checkOrCross = marker[0];

				if (checkOrCross == "Check") {
					noChecksPerWeek++;
					checksPerDay++;
				} else if (checkOrCross == "Cross") {
					noCrossesPerWeek++;
					crossesPerDay++;
				} else {
					console.error("Fuck " + checkOrCross);
				}

			} // end of for loop ... read all items markers

		}// end of for loop ,... mealsPerDay.length

		var noMealsFactor = 0;

		if (noMealsPerDay > 3) {
			noMealsFactor = 50;
		} else if (noMealsPerDay > 0) {
			noMealsFactor = 30;
		} else {
			noMealsFactor = 0;
		}

		var checksFactor = Math.round(checksPerDay / (checksPerDay + crossesPerDay) * 50);

		if (!checksFactor) {
			checksFactor = 0;
		}

		var efficiencyPerDay = noMealsFactor + checksFactor;

		efficiencyDataWeekly[i] = efficiencyPerDay;

		// Calculate efficiency then

		console.log("Meals Per Day Summary : " + JSON.stringify(groupedByDay[dates[i].label]));

	}// end of dates.length loop

	//NOW :

	var peakDay = weekday[dates[maximumMealsPerDayIndex].day];

	var avgEfficiency = calculateAvgEfficiency(efficiencyDataWeekly);

	return {
		efficiencyDataWeekly : efficiencyDataWeekly,
		avgEfficiency : avgEfficiency,
		peakDay : peakDay,
		noChecksPerWeek : noChecksPerWeek,
		noCrossesPerWeek : noCrossesPerWeek,
		noMealsPerWeek : noMealsPerWeek
	};

};

var populateThisWeekSummaryCard = function(results, mealsForWeek, userPointer, coachPointer, beginDate) {

	thisWeekSummaryCard = results[0];

	var currentWeek = thisWeekSummaryCard.get('weekNumber');

	// Set all other parameters.

	var summaryData = calculateWeekSummary(mealsForWeek, beginDate);

	thisWeekSummaryCard.set("efficiency", summaryData.avgEfficiency);
	thisWeekSummaryCard.set("checks", summaryData.noChecksPerWeek);
	thisWeekSummaryCard.set("crosses", summaryData.noCrossesPerWeek);
	thisWeekSummaryCard.set("meals", summaryData.noMealsPerWeek);
	thisWeekSummaryCard.set("peakDay", summaryData.peakDay);
	// thisWeekSummaryCard.set("weekNumber", ); Week Label already set
	thisWeekSummaryCard.set("efficiencyDataWeek", summaryData.efficiencyDataWeekly);
	thisWeekSummaryCard.set("summaryCreatedAt", new Date());
	thisWeekSummaryCard.set("user", userPointer);
	thisWeekSummaryCard.set("coach", coachPointer);

	// Monthly Efficiency Data :
	var efficiencyDataMonth = [];

	// Summaries are ordered descending , and limited to 4.

	for (var jj = results.length - 1; jj >= 0; jj--) {

		var weekSum = results[jj];

		var weekNum = weekSum.get('weekNumber');
		var weekSumSum = weekSum.get('efficiencyDataWeek');

		var weekName = "Week " + weekNum;

		efficiencyDataMonth.push({
			Data : weekSumSum,
			weekName : weekName
		});
	}

	thisWeekSummaryCard.set("efficiencyDataMonth", efficiencyDataMonth);

	return thisWeekSummaryCard;

};

var populateNextWeekSummaryCard = function(weekNumber, userPointer, coachPointer) {

	var SummaryCard = Parse.Object.extend("SummaryCard");
	var nextWeekSummaryCard = new SummaryCard();
	nextWeekSummaryCard.set("weekNumber", weekNumber);
	// Summary created At should be left null.
	nextWeekSummaryCard.set("user", userPointer);
	nextWeekSummaryCard.set("coach", coachPointer);

	return nextWeekSummaryCard;

};

/*
 TODO: Who creates initial Summary Card and when ???????

 */
var saveUserMealSummary = function(coachPointer, userPointer, beginDate, endDate, profileBeginDate, beginWeekDay) {

	var userId = JSON.stringify(userPointer);
	var coachId = JSON.stringify(coachPointer);

	console.log("Processing summary for [" + userId + "] with coach [" + coachId + "] Dates between: [" + beginDate + "] and [" + endDate + "] Begin Week Day [" + beginWeekDay + "] Profile Begin Date [" + profileBeginDate + "]");

	/*
	DO NOT RESET HOURS , HOURS ARE IMPORTANT SINCE we ARE WORKING ACCROSS TIMEZONES ...
	// All dates here have to be reset - hours minutes seconds millis to 0 0 0 so we are only looking at days . not hours
	profileBeginDate = utils.resetHours(new Date(profileBeginDate));
	beginDate = utils.resetHours(new Date(beginDate));
	endDate = utils.resetHours(new Date(endDate));
	
	*/
	// Look at Profile Begin date, which day it was ...
	// If its equals, then it's best scenario
	// If Begin date day is after , good scenario
	// If before , we need to advance a week.
	var profileBeginDay = profileBeginDate.getDay();

	// we need to advance the clock from profile start date until we get to the Week date :
	// Example  1 :  Start date = 0 , week start date =1 ... advance by 1 day
	// Example 2 : start date = 1 , week start date = 1 .. great.
	// Example 3 : start date = 3 , week start date = 1 ... advance by 5 days

	var diffInDays = (7 + (beginWeekDay - profileBeginDay)) % 7;

	var week1StartDate = new Date(profileBeginDate.getTime() + utils.daysToMillis(diffInDays));

	var userWeekNumber = Math.floor((Math.abs(beginDate.getTime() - week1StartDate.getTime())) / utils.daysToMillis(7)) + 1;

	console.log("Processing summary for [" + userId + "] with coach [" + coachId + "] Dates between: [" + beginDate + "] and [" + endDate + "] Week1 Start Date is [" + week1StartDate + "] Begin Week Day [" + beginWeekDay + "] Profile Begin Date [" + profileBeginDate + "] Week Number [" + userWeekNumber + "]");

	//Query meals, meals need to be UNLOCKED, if Locked, them Summary has already run ... we should not produce a new summary
	var query = new Parse.Query("Meal");
	query.greaterThanOrEqualTo("appCreatedAt", beginDate);
	query.lessThan("appCreatedAt", endDate);
	query.equalTo("user", userPointer);
	// Summary created At should be null;
	query.doesNotExist("summaryCreatedAt");
	query.equalTo("coach", coachPointer);
	query.ascending("appCreatedAt");

	// We have to query for the latest summary card
	var SummaryCard = Parse.Object.extend("SummaryCard");
	var summaryQuery = new Parse.Query(SummaryCard);
	summaryQuery.equalTo("user", userPointer);
	summaryQuery.equalTo("coach", coachPointer);
	// We can limit this query to 4 results... since 4 is all we need to construct a month's summary
	summaryQuery.limit(4);
	summaryQuery.descending("weekNumber");
	// we don't filter by locked unlocked to get everything.. We need everything

	var mealsForWeek = null;
	var summaryCreatedAtDate = null;

	return query.find().then(function(mealsPerQueryWeek) {

		console.log("Meals Per Week for user " + userId + " coach " + coachId + " number of meals : " + mealsPerQueryWeek.length);

		mealsForWeek = mealsPerQueryWeek;
		//Load the summary Cards for this dude
		return summaryQuery.find();

	}).then(function(results) {

		console.log("Finding all Summary Cards " + results.length);

		if (results.length == 0) {
			// We should not be here... Since this means no Initial summary card has been created when a user has been created.. FAIL this user.
			console.error("Saving next summary for " + userId + " with coach " + coachId + " Dates between: [" + beginDate + "] and [" + endDate + "] FAILED !!!.. Unable to find summary card ");

			return Parse.Promise.error("Data Error : No initial summary card created for " + userId + " with coach " + coachId + " Dates between: [" + beginDate + "] and [" + endDate + "] FAILED !!!");
		}

		var thisWeekCard = results[0];

		var cardWeekNum = thisWeekCard.get('weekNumber');

		//TODO: We are likely to end up here is a user was processed before .... .... .... Should be Skipped..
		if (cardWeekNum != userWeekNumber) {

			return Parse.Promise.error("Data Error : Card Week Number does not match user Week Number " + userId + " with coach " + coachId + " Dates between: [" + beginDate + "] and [" + endDate + "] CardWeekNumber[" + cardWeekNum + "] UserWeekNumber [" + userWeekNumber + "]");
		}

		var isProcessedBefore = thisWeekCard.get('summaryCreatedAt');

		if (isProcessedBefore) {

			return Parse.Promise.error("Data Error : Summary has been processed before " + userId + " with coach " + coachId + " Dates between: [" + beginDate + "] and [" + endDate + "] FAILED !!!");
		}

		var thisWeekSummaryCard = populateThisWeekSummaryCard(results, mealsForWeek, userPointer, coachPointer, beginDate);

		// Save the summary
		return thisWeekSummaryCard.save();

	}).then(function(savedThisWeekSummaryCard) {

		var weekNumber = savedThisWeekSummaryCard.get('weekNumber') + 1;

		summaryCreatedAtDate = savedThisWeekSummaryCard.get('summaryCreatedAt');

		var nextWeekSummaryCard = populateNextWeekSummaryCard(weekNumber, userPointer, coachPointer);

		return nextWeekSummaryCard.save();

	}).then(function(nextWeekSummaryCard) {

		var promises = [];

		_.each(mealsForWeek, function(meal) {

			meal.set("summaryCreatedAt", summaryCreatedAtDate);

			promises.push(meal.save());

		});

		return Parse.Promise.when(promises);

	});

	//TODO: Send Push notifications here...

};

var processUsersSummary = function() {
	
	// For all Supported Timezones.
	// If now is midnight for this timezone. 
	// Find the day of week , Query Client info for Customers who today is end of week for, Based on the current date + Timezone.
	// Make sure they are linked to the appropraite coach. 

	// If Time now corresponds to a midnight in a supported timezone....
	
	//TODO: For now we know everyone is in Toronto... and the team. Later we need to query all users. get all timezones..
	
	var now=new Date();
	
	for(var tzIndex=0; tzIndex< supportedTimezones.length;tzIndex++){
		
		if(isMidnight(now,supportedTimezones[tzIndex])){
			
			// For this Timezone, and for this day of week, find users who we need to query on.
			
			
			
		}
		
		
	}
	
	

	// Query Users table. Get all users who are not coaches, who have a coach ...

	// Today is end  day ..
	// Note that this date is in UTC ... ... We are 7 hours diff.
	var d = new Date();

	// Start day is today
	//  var startDate = (d.getDay() + 1)%7;
	var startDate = d.getDay();

	// convert to a start date string
	var weekStartDay = weekDayToString(startDate);

	console.log("Processing items - beginning of week is :  " + weekStartDay);

	var todayMidnight = utils.resetHours(d);

	// last week midnight

	// Subtract 7 days from today ...
	var lastWeekmidnight = new Date();
	lastWeekmidnight.setTime(todayMidnight.getTime() - utils.daysToMillis(7));

	var ClientInfo = Parse.Object.extend("ClientInfo");
	var query = new Parse.Query(ClientInfo);

	query.equalTo("weekStartDay", weekStartDay);

	// What if these guys already have their cards processed.

	//TODO: once you have 100 users consider pagination maybe ???

	return query.find().then(function(results) {

		console.log("Results length " + results.length);

		var promises = [];

		_.each(results, function(result) {

			var cInfo = result;

			var profileBeginDate = cInfo.createdAt;
			var beginWeekDay = startDate;
			var coachRef = cInfo.get('coach');
			var userRef = cInfo.get('user');

			//TODO: Do not go to coach user link. Go to User Table Directly, referring user and coach. if we get a result. great process 
			// otherwise it is old. should Skip.
			// This way we have user entity. Can get timezone.

			var CoachUserLink = Parse.Object.extend("CoachUserLink");
			var coachUserQuery = new Parse.Query(CoachUserLink);

			coachUserQuery.equalTo("user", userRef);
			coachUserQuery.equalTo("coach", coachRef);
			coachUserQuery.doesNotExist("terminatedAt");
			coachUserQuery.doesNotExist("rejectedAt");
			coachUserQuery.exists("linkedAt");

			var promise = coachUserQuery.find().then(function(coachUserLinks) {

				console.log("References coach: " + JSON.stringify(coachRef) + " user Ref :" + JSON.stringify(userRef) + " Length " + coachUserLinks.length);

				if (coachUserLinks.length == 1) {
					//Make sure that user and coach are still linked ...

					console.log("Today " + todayMidnight + " Last week " + lastWeekmidnight);
					return saveUserMealSummary(coachRef, userRef, lastWeekmidnight, todayMidnight, profileBeginDate, beginWeekDay);

				} else if (coachUserLinks.length == 0) {
					console.log("User linked to Coach no longer active- Skipping : Coach:" + JSON.stringify(coachRef) + "User:" + JSON.stringify(userRef));
					return Parse.Promise.as("No Active user link - Skipping");
				} else {
					//ERROR here...
					console.error("User linked to Coach DATA ISSUE : Coach:" + JSON.stringify(coachRef) + "User:" + JSON.stringify(userRef));
					// Return a failed promise
					return Parse.Promise.error("Data Error : Multiple active user coach links found for " + userId + " with coach " + coachId + " Dates between: [" + beginDate + "] and [" + endDate + "] FAILED !!!");
				}

			});

			promises.push(promise);

		});
		//end of for each

		// Return a new promise that is resolved when all of the others are finished.
		return Parse.Promise.when(promises);
	});

};

exports.weekDayToString = weekDayToString;
exports.processUsersSummary=processUsersSummary;
exports.saveUserMealSummary=saveUserMealSummary;